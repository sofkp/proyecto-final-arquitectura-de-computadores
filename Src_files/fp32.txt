// Carga f1=5.0, f2=2.375 desde memoria
40A000B7  // lui x1,0x40A00          # x1=0x40A00000 (5.0)
00008093  // addi x1,x1,0
40180137  // lui x2,0x40180          # x2=0x40180000 (2.375)
00010113  // addi x2,x2,0
00102023  // sw x1,0(x0)             # mem[0]=5.0
00202223  // sw x2,4(x0)             # mem[4]=2.375
00002087  // flw f1,0(x0)            # f1=5.0
00402107  // flw f2,4(x0)            # f2=2.375

// [FP32 – Forwarding EX/MEM]
002081D3  // fadd.s f3,f1,f2         # f3=7.375 -> 0x40EC0000
08218253  // fsub.s f4,f3,f2         # f4=5.0   -> 0x40A00000 (RAW -> ForwardAE)

// [FP32 – Forwarding MEM/WB]
102082D3  // fmul.s f5,f1,f2         # f5=11.875 -> 0x413E0000
00100513  // addi x10,x0,1           # independiente
18128353  // fdiv.s f6,f5,f1         # f6≈2.375  (RAW -> Forward desde MEM/WB)

// [FP32 – load-use hazard (flw → fadd.s)]
00602427  // fsw f6,8(x0)            # mem[8]=f6
00802387  // flw f7,8(x0)            # f7=f6 (load)
00238453  // fadd.s f8,f7,f2         # usa f7 inmediato -> debe haber StallF/StallD=1

// [FP32 – store después de FP (forward a store)]
081484D3  // fsub.s f9,f8,f1         # f9=(f7+f2)-f1
00902427  // fsw f9,12(x0)           # store usando valor recién producido

// [FP32 – casos especiales: pi ~3.14159 y 1e-5]
404905B7  // lui x11,0x40490        # x11=0x40490FD0 (~3.14159)
FD058593  // addi x11,x11,0xFD0
00B02823  // sw x11,16(x0)          # mem[16]=pi
3727C637  // lui x12,0x3727C        # x12=0x3727C5AC (~1e-5)
5AC60613  // addi x12,x12,0x5AC
00C02A23  // sw x12,20(x0)          # mem[20]=1e-5
01002507  // flw f10,16(x0)         # f10=pi
01402587  // flw f11,20(x0)         # f11=1e-5
00B50653  // fadd.s f12,f10,f11     # ~3.1416001 -> 0x40490FFA
08B506D3  // fsub.s f13,f10,f11     # ~3.141579  -> 0x40490FA6
10B50753  // fmul.s f14,f10,f11     # ~3.14159e-5 -> 0x3803C491
18B507D3  // fdiv.s f15,f10,f11     # ~3.14159/1e-5 -> 0x489965E1
00C02C27  // fsw f12,24(x0)
00D02E27  // fsw f13,28(x0)
02E02027  // fsw f14,32(x0)
02F02227  // fsw f15,36(x0)
